## Syntax

**Transitivity Operator**

```arend
\func \infixr 5 *> {A : \Type} {a a' a'' : A} (p : a = a') (q : a' = a'') : a = a''

```

**Equational Reasoning Operators**

```arend
\func \infix 2 qed {A : \Type} (a : A) : a = a
\func \infixr 1 >== {A : \Type} {a a' a'' : A} (p : a = a') (q : a' = a'') : a = a''
\func \infix 2 ==< {A : \Type} (a : A) {a' : A} (p : a = a') : a = a'

```

**J Eliminator (Dependent Path Induction)**

```arend
\func J {A : \Type} {a : A}
        (B : \Pi (a' : A) -> a = a' -> \Type)
        (b : B a idp)
        {a' : A} (p : a = a') : B a' p

```

**Alternative J (Jalt)**

```arend
\func Jalt {A : \Type} (B : \Pi (a a' : A) -> a = a' -> \Type)
           (b : \Pi (a : A) -> B a a idp)
           {a a' : A} (p : a = a') : B a a' p

```

## Rules

### 1. Transitivity and Composition

* **Definition**: The operator `*>` is defined via `transport`.
* **Behavior**: `p *> q` composes path `p` (from `a` to `a'`) and `q` (from `a'` to `a''`) to form a path `a = a''`.
* **Identity**: `p *> idp` computationally reduces to `p`.

### 2. Equational Reasoning

* **Purpose**: Provides syntactic sugar for constructing long chains of transitive equality proofs in a readable, vertical layout.
* **Structure**:
* `==<`: Initiates a step, specifying the term `a` and the proof `p` that `a = a'`.
* `>==`: Chaining operator (synonym for `*>`).
* `qed`: Terminates the chain with reflexivity (`idp`), returning the final term.


* **Notation**: Supports infix (`x `f` y`) and postfix (`x `f`) notation for readability.

### 3. J Eliminator and Pattern Matching

* **Semantics**: `J` postulates that the identity type is generated by `idp`. To prove a property `B` for all paths `p : a = a'`, it suffices to prove it for `idp`.
* **Implementation**: `J` is implemented via `coe` (coercion) and `psqueeze`.
* **Pattern Matching Principle**:
* A parameter of type `a = a'` can be matched with `idp`.
* **Constraint**: This matching forces `a` and `a'` to unify.
* **Underlying Theory**: Matching on `idp` is not matching on the type `a = a'` (which may contain multiple paths), but rather simultaneous matching on the pair `(a', p)` in the type `\Sigma (x : A) (a = x)`. This Sigma type is a singleton (contractible).


* **Contrast with K**: The K eliminator (Uniqueness of Identity Proofs) implies `p = idp` for all `p : a = a`. Arend **does not** assume K; proofs of equality are not unique.

### 4. Transport Interaction

* **Type Modification**: `transport` allows term substitution across types that are equal (e.g., `Vec A (n+m)` to `Vec A (m+n)`).
* **Constructor Commutativity**: `transport` commutes with data constructors.
* *Example*: `transport (Vec A) p (vcons x xs) = vcons x (transport (Vec A) p xs)`.
* These commutation properties must often be proven explicitly using `J` or pattern matching on `idp`.



### 5. Predicates

* **Definition**: A function `A -> \Type` (in propositions-as-types logic).
* **Construction Methods**:
1. **Combinatoric**: Using Sigma types and equality (e.g., `\Sigma (k) (n = 2 * k)`).
2. **Recursive**: Standard function definition (only for inductive data types).
3. **Inductive**: Using `\data` to define the predicate as a family of types generated by constructors.


* **Equivalence**: Different encodings of the same predicate (e.g., recursive vs. inductive `<=`) are extensionally equivalent but distinct in definition.

## Examples

### Commutativity of Addition (Standard & Equational)

```arend
-- Standard usage of pmap, inv, and *>
\func +-comm (n m : Nat) : n + m = m + n
  | 0, 0 => idp
  | suc n, 0 => pmap suc (+-comm n 0)
  | 0, suc m => pmap suc (+-comm 0 m)
  | suc n, suc m => pmap suc (+-comm (suc n) m *> pmap suc (inv (+-comm n m)) *> +-comm n (suc m))

-- Usage of Equational Reasoning
\func +-comm' (n m : Nat) : n + m = m + n
  | 0, 0 => idp
  | suc n, 0 => pmap suc (+-comm' n 0)
  | 0, suc m => pmap suc (+-comm' 0 m)
  | suc n, suc m => pmap suc (
    suc n + m   ==< +-comm' (suc n) m >==
    suc (m + n) ==< pmap suc (inv (+-comm' n m)) >==
    suc (n + m) ==< +-comm' n (suc m) >==
    suc m + n   `qed
  )

```

### Transport with Vectors (J required)

```arend
\func v++-assoc {A : \Type} {n m k : Nat} (xs : Vec A n) (ys : Vec A m) (zs : Vec A k)
  : (xs v++ ys) v++ zs = transport (Vec A) (+-assoc k m n) (xs v++ (ys v++ zs)) \elim n, xs
  | 0, vnil => idp
  | suc n, vcons x xs =>
      pmap (vcons x) (v++-assoc xs ys zs) *>
      inv (transport-vcons-comm (+-assoc k m n) x (xs v++ (ys v++ zs)))
  \where
    -- Lemma proving transport commutes with vcons
    -- Pattern matching on 'idp' implicitly uses J semantics
    \func transport-vcons-comm {A : \Type} {n m : Nat} (p : n = m) (x : A) (xs : Vec A n)
      : transport (Vec A) (pmap suc p) (vcons x xs) = vcons x (transport (Vec A) p xs)
      | idp, _, _ => idp

```

### Predicate Definitions (LessOrEq)

```arend
-- 1. Via Sigma/Equality
\func LessOrEq_Sigma (n m : Nat) => \Sigma (k : Nat) (k + n = m)

-- 2. Recursive
\func lessOrEq_Rec (n m : Nat) : \Type
  | 0, _ => Unit
  | suc _, 0 => Empty
  | suc n, suc m => lessOrEq_Rec n m

-- 3. Inductive (Standard)
\data LessOrEq_Ind (n m : Nat) \with
  | 0, m => z<=n
  | suc n, suc m => s<=s (LessOrEq_Ind n m)

-- 4. Inductive (Alternative Axiomatization)
\data LessOrEq_Alt (n m : Nat) \elim m
  | suc m => <=-step (LessOrEq_Alt n m)
  | m => <=-refl (n = m)

```